## 符号追踪

到目前为止，在我们的 Monkey 代码中，我们通过使用布尔和整数字面量来引用值。这种情况即将改变。在本章中，我们将通过添加对 `let` 语句和支持标识符表达式的支持来实现绑定。最终，我们将能够将任何值绑定到任何名称，并使该名称解析为对应的值。

作为准备，这里简要回顾一下 Monkey 中的 `let` 语句是什么样子：

```
let x = 5 * 5;
```

如您所见，Monkey 中的 `let` 语句以 `let` 关键字开头，后跟一个标识符。这个标识符是我们想要绑定值的名称，在这里它是 `x` 。等号右侧是一个表达式，它计算出的值就是名称将要绑定到的值。因为这是一个 `let` 语句，所以其后跟着一个分号。让名称等于表达式的值；就是这样。

引用 `x` 所绑定的值很简单，因为在我们的抽象语法树（AST）术语中， `x` 是一个标识符，而标识符是表达式，并且可以互换使用。我们可以在任何允许表达式的地方使用 `x` ：

```
x * 5 * x * 5;
if (x < 10) { x * 2 } else { x / 2 };
let y = x + 5;
```

`let` 语句可以作为顶层语句或块语句内部的语句使用，比如条件分支或函数体。在本章中，我们只会添加对顶层 `let` 语句以及非函数体内的块语句的支持。当我们实现函数和闭包时，我们将处理局部变量，即函数内部的 `let` 语句所产生的变量。

本章的目标是能够将以下代码编译成字节码，并让我们的虚拟机执行它：

```
let x = 5 * 5;
if (x > 10) {
    let y = x * 2;
    y;
}
```

并且，是的，它也应该能够正确执行这段代码并在这里产生 `50` 的结果。

### 计划

那么我们该如何实现这一点呢？显然，我们需要将 `let` 语句和标识符表达式编译成字节码指令，并在虚拟机中支持这些指令。这点是明确的。而且我认为关于需要多少新的操作码也没有什么争议。我们需要一个操作码来告诉虚拟机将值绑定到标识符，另一个操作码用于检索先前绑定到标识符的值。但是这些新指令具体是什么样的呢？

实现绑定的主要任务是让标识符能够正确解析到它们之前绑定的值。如果你可以在执行代码时传递标识符——就像我们在求值器中所做的那样——这并不是很大的挑战。例如，你可以使用标识符作为映射的键，在其中存储和检索值。但我们现在不能这样做。

我们已经不在求值器里了。我们现在正在处理字节码，我们不能直接在字节码中传递标识符——我们的操作码的操作数是整数。那么我们如何在这些新指令中表示标识符呢？以及，我们如何引用应该绑定到标识符的值？

第二个问题的答案由两个词组成，所以我们先从这个开始。答案就是：栈。是的，就是这样，我们不需要更多了。我们不需要显式地引用想要绑定的值——我们有一个基于栈的机器！我们可以简单地将值压入栈顶，然后告诉虚拟机：“现在将栈顶元素绑定到这个标识符”。这与我们其余的指令集完美契合。

回到第一个问题：当我们只能使用数字作为操作数时，如何在字节码中表示标识符？答案就隐藏在问题本身之中：我们将使用数字来表示标识符。让我用一点 Monkey 代码来解释这一点：

```
let x = 33;
let y = 66;
let z = x + y;
```

在编译过程中，我们将为遇到的每个标识符分配一个新的、唯一的数字。如果之前已经见过该标识符，我们将重用之前分配的数字。我们如何生成新的数字？我们会保持简单，从 `0` 开始使用递增的数字。在这个例子中， `x` 会被分配 `0` ， `y` 被分配 `1` ，而 `z` 则被分配 `2` 。

我们还将定义两个新的操作码，并将它们称为 OpSetGlobal 和 OpGetGlobal。两者都有一个 16 位宽的操作数来存储数字：这是我们之前分配给标识符的唯一数字。当我们编译 `let` 语句时，我们将发出一个 OpSetGlobal 指令来创建绑定；当编译标识符时，我们将发出一个 OpGetGlobal 指令来检索值。（16 位操作数意味着我们最多只能有 `65536` 个全局绑定——这对于我们的 Monkey 程序来说应该是绰绰有余的。）

上面提到的三个 Monkey 的 `let` 语句在字节码中看起来会是这样的：

![符号追踪](/pic/符号追踪1.png)

这确实是编译器方面的工作。在虚拟机（VM）中，我们将使用一个切片来实现全局绑定的创建和检索。我们将这个切片称为“全局存储”，并使用 OpSetGlobal 和 OpGetGlobal 指令的操作数作为索引。

当执行 OpSetGlobal 指令时，我们将读取操作数，从栈顶弹出值，并将其保存到由操作数指定的全局存储索引位置。为了执行 OpGetGlobal 指令，我们将使用操作数从全局存储中检索值，并将其压入栈顶。

两个新的操作码 OpGetGlobal 和 OpSetGlobal，一个在编译时将标识符与数字关联起来的机制，以及虚拟机中的全局存储。这样分解来看，听起来是可行的，对吧？

当然，一旦引入函数和局部变量，事情就会变得更加复杂，但那是我们之后要解决的问题。现在，让我们转向我们的编译器。

|[⬅ Null](./29Null.md)|[编译绑定 ➡](./31编译绑定.md)|
| --- | --- |
