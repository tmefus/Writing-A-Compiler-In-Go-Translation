### 从字节开始

我们到了这一步。我们需要定义我们的第一个字节码指令。我们该怎么做呢？好吧，因为在编程时创建定义无非是告诉计算机我们知道什么，让我们问问自己：关于字节码我们知道些什么？

我们知道它是由指令组成的。我们也知道这些指令本身是一系列的字节，而一个单独的指令由操作码和可选数量的操作数组成。操作码正好是一个字节宽，具有任意但唯一的值，并且是指令中的第一个字节。看起来我们知道得相当多，而且最好的是，这个信息足够精确，可以转化为代码——字面意义上的。

作为本书中我们正式实践编码的第一个动作，我们将创建一个新的包，称为 `code` ，在这里我们将开始定义我们的 Monkey 字节码格式：

```go
// code/code.go

package code
type Instructions[] byte
type Opcode byte
```

指令是一个字节切片，而操作码是一个字节。这与我们在描述中提到的非常吻合。但是这里缺少了两个定义。

第一个是单数形式的指令（Instruction）。为什么我们没有将它定义为 `[]byte` ？ 因为在 Go 的类型系统中，传递和处理 `[]byte` 作为隐式的指令比明确地编码成 Instruction 类型要方便得多。很快你就会看到我们会多么频繁地使用 `[]byte` ，以及如果在 Instruction 类型之间进行类型断言和类型转换会有多么繁琐。

另一个缺失的定义是关于字节码（Bytecode）的。至少应该有一个定义告诉我们字节码是由指令组成的，对吧？这个定义之所以缺失是因为如果我们在这里的 code 包中定义 Bytecode，那么会导致一个讨厌的导入循环。不过，这个定义不会缺失太久。当我们开始编写编译器时，我们会在编译器包中定义它。

现在我们有了 Opcode 和 Instructions 的定义，我们可以定义我们的第一个操作码，也就是告诉虚拟机将某些东西压入栈的操作码。这里有个意外：操作码的名字中不会有“push”。实际上，它不仅仅关于压栈。让我来解释一下。

早些时候我们说过，当编译 Monkey 表达式 `1 + 2` 时，我们想要生成三个不同的指令；其中两个指令告诉虚拟机将 1 和 2 压入栈。第一直觉可能是通过定义一个带有整数操作数的“push”指令来实现这些，这样虚拟机就可以取到整数操作数并将其压入栈。对于整数来说这样做没问题，因为我们可以轻松地对它们进行编码并直接放入字节码中。但是如果以后我们想压入 Monkey 代码中的其他内容呢？例如字符串字面量。把这些放入字节码也是可能的，毕竟字节码只是由字节组成，但这也会带来大量的冗余，并且迟早会变得难以管理。

这就是常量概念发挥作用的地方。在这种情况下，“常量”是指“常量表达式”，指的是那些值不改变、是固定的，并且可以在**编译时**确定的表达式：

![执行过程](/pic/字节码4.png)

这意味着我们不需要运行程序就能知道这些表达式的计算结果。编译器可以在代码中找到它们，并存储它们的计算值。之后，编译器在生成的指令中引用这些常量，而不是直接将值嵌入到指令中。虽然“引用”听起来像是一个特殊的数据类型，但实际上它要简单得多。一个普通的整数就足够了，它可以作为索引进入一个持有所有常量的数据结构，这个数据结构通常被称为常量池。

而这正是我们的编译器将要做的。当我们编译时遇到整数字面量（一个常量表达式），我们会评估它并将得到的 *object. Integer 对象存储在内存中，并给它分配一个编号。在字节码指令中，我们将通过这个编号来引用 *object. Integer 对象。当我们完成编译并将指令传递给虚拟机执行时，我们也会将找到的所有常量放入一个数据结构——我们的常量池——其中每个常量被分配的编号可以用来作为索引来检索它。

回到我们的第一个操作码。它被称为 OpConstant，它有一个操作数：我们之前分配给常量的编号。当虚拟机执行 OpConstant 时，它会使用操作数作为索引来检索常量并将其压入栈中。这里是我们第一个操作码的定义：

在中文环境中，上述内容可以翻译如下：

这意味着我们不需要运行程序就能知道这些表达式的计算结果。编译器可以在代码中找到它们，并存储它们的计算值。然后，在生成的指令中，编译器会引用这些常量，而不是直接把值嵌入到指令里。尽管“引用”听起来像是某种特殊的数据类型，但实际上它远比这简单。一个普通的整数就足够用了，它可以作为一个索引指向一个存放所有常量的数据结构，这个数据结构通常被称为常量池。

而这正是我们的编译器将会做的事情。在编译过程中，当我们遇到整数字面量（一个常量表达式）时，我们会计算它的值，并将得到的 `*object.Integer` 对象存储在内存中，同时为它分配一个数字标识。在生成的字节码指令中，我们将通过这个数字标识来引用 `*object.Integer` 对象。当编译完成后，我们将指令传递给虚拟机执行时，我们还会将找到的所有常量放入一个数据结构——即我们的常量池——在这个数据结构中，每个常量所分配的数字标识可以作为索引来获取它。

现在回到我们的第一个操作码。这个操作码被称为 OpConstant，它带有一个操作数：就是我们先前分配给常量的那个数字标识。当虚拟机执行 OpConstant 时，它会使用该操作数作为索引来从常量池中检索出相应的常量，并将其压入栈上。以下是我们第一个操作码的定义：

```go
// code/code.go

// [...]

const (
    OpConstant Opcode = iota
)
```

尽管这看起来就像简简单单的三行代码，但这一添加却是未来所有操作码定义的基础。每个定义都将有一个 Op 前缀，并且它所指代的值将由 `iota` 确定。我们让 `iota` 为我们生成递增的字节值，因为我们并不关心操作码实际代表的具体数值。它们只需要彼此不同，并且能够用一个字节来表示即可。 `iota` 会确保这一点。

在这个定义中缺少的部分是指出 OpConstant 有一个操作数。从技术上讲，没有必要写下这一点，因为编译器和虚拟机之间可以隐式地共享这个信息。然而，为了调试和测试的目的，能够查找到一个操作码有多少个操作数以及它的可读名称是非常方便的。为了实现这一点，我们将向 `code` 包中添加适当的定义和一些工具支持:

```go
// code/code.go

import "fmt"

type Definition struct {
    Name            string
    OperandWidths[] int
}

var definitions = map[Opcode] * Definition {
    OpConstant: {"OpConstant", []int{2}},
}

func Lookup(op byte)( * Definition, error) {
    def, ok := definitions[Opcode(op)]
    if !ok {
        return nil, fmt.Errorf("opcode %d undefined", op)
    }
    return def, nil
}
```

操作码（Opcode）的定义包含两个字段：名称（Name）和操作数宽度（OperandWidths）。名称帮助使操作码可读，而操作数宽度则包含了每个操作数占用的字节数。

对于 OpConstant 的定义说明了它的唯一操作数是两个字节宽，这使得它是一个 uint16 类型，并将其最大值限制为 65535。如果我们包括 0 在内，那么可以表示的数值总数就是 65536。对于我们来说，这个数量应该是足够的，因为我不认为我们的 Monkey 程序会引用超过 65536 个常量。而且使用 uint16 而不是比如说 uint32，有助于保持生成的指令更小，因为这样会有较少的未使用字节。

有了这样的定义之后，我们现在可以创建我们的第一个字节码指令。如果没有涉及任何操作数，那就简单地将一个操作码添加到指令切片中。但是对于 OpConstant，我们需要正确编码这个两字节的操作数。

为此，我们将创建一个函数，允许我们轻松创建由一个操作码和可选数量的操作数组成的单个字节码指令。我们将这个函数命名为 `Make` ，这样在其他包中就可以使用非常棒的标识符 `code.Make` 。

接下来是大家期待的内容，这是本书中的第一个测试，展示了我们希望 `Make` 函数能够实现的功能：

```Go
// code/code_test.go

package code

import "testing"

func TestMake(t * testing.T) {
    tests := [] struct {
        op          Opcode
        operands[]  int
        expected[]  byte
    } {
        { OpConstant, []int{65534}, []byte{byte(OpConstant), 255, 254} },
    }
    for _, tt := range tests {
        instruction := Make(tt.op, tt.operands...)
        if len(instruction) != len(tt.expected) {
            t.Errorf("instruction has wrong length. want=%d, got=%d", len(tt.expected), len(instruction))
        }
        for i, b := range tt.expected {
            if instruction[i] != tt.expected[i] {
                t.Errorf("wrong byte at pos %d. want=%d, got=%d", i, b, instruction[i])
            }
        }
    }
}
```

不要因为测试只包含一个测试用例而感到沮丧。当我们向代码词汇中添加更多的操作码时，我们会扩展这个测试。

目前，我们只是将 OpConstant 和操作数 65534 传递给 Make 函数。然后我们期望得到一个包含三个字节的 []byte。在这三个字节中，第一个必须是操作码 OpConstant，而另外两个应该是 65534 的大端序编码。这也是为什么我们使用 65534 而不是最大值 65535：这样我们可以检查最高有效字节是否在前。65534 在大端序下会被编码为字节序列 0xFF 0xFE，而 65535 则会被编码为 0xFF 0xFF —— 这样很难识别顺序。

由于 Make 函数还不存在，测试不会失败，但编译会失败，所以这里是 Make 函数的第一个版本：

```Go
// code/code.go

import(
    "encoding/binary"
    "fmt"
)

func Make(op Opcode, operands...int)[]byte {
    def, ok := definitions[op]
    if !ok {
        return []byte{}
    }
    instructionLen := 1
    for _, w := range def.OperandWidths {
        instructionLen += w
    }
    instruction := make([] byte, instructionLen)
    instruction[0] = byte(op)
    offset := 1
    for i, o := range operands {
        width := def.OperandWidths[i]
        switch width {
            case 2:
                binary.BigEndian.PutUint16(instruction[offset:], uint16(o))
        }
        offset += width
    }
    return instruction
}
```

这就是你如何生成字节码。

我们在这里首先要做的是确定最终指令的长度。这允许我们分配一个具有适当长度的字节切片。请注意，我们没有使用 Lookup 函数来获取定义，这样做给了我们在测试中使用 Make 时一个更易用的函数签名。通过绕过 Lookup 并且不必返回可能的错误，我们可以使用 Make 来轻松构建字节码指令，而无需在每次调用后检查错误。使用未知操作码产生空字节切片的风险是我们愿意承担的，因为我们是在生产侧，并且在创建指令时知道自己在做什么。

一旦我们得到了 instructionLen 的最终值，我们就分配 instruction []byte 并将 Opcode 作为其第一个字节添加进去——通过将其转换为一个字节。接下来是棘手的部分：我们遍历定义的 OperandWidths，从 operands 中取出匹配的元素并放入指令中。我们通过使用 switch 语句来实现这一点，根据操作数的宽度为每个操作数采用不同的方法。

随着我们定义额外的操作码，我们将很快需要扩展这个 switch 语句。目前，我们只确保一个两字节的操作数以大端序编码。虽然手动完成这项工作并不难，但我们使用标准库中的 `binary.BigEndian.PutUint16` 来实现这一点，这样做的好处是可以立即看到编码的名称。

在编码了操作数之后，我们按照其宽度增加偏移量，并进行循环的下一次迭代。由于我们的测试用例中的 OpConstant 操作码只有一个操作数，因此在 Make 返回 instruction 之前，循环只执行一次迭代。

而且，你看，我们的第一个测试现在编译成功并通过了：

```GO
$ go test ./code
ok      monkey/code 0.007s
```

我们成功地将 OpConstant 和操作数 65534 转换成了三个字节。这意味着我们创建了我们的第一条字节码指令！

|[⬅ 第一个指令](./12第一个指令.md)|[最小的编译器 ➡](./14最小的编译器.md)|
| --- | --- |
