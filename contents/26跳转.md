## 跳转

跳跃是指令，告诉机器跳转到其他指令。它们用于在机器码中实现分支（条件语句），因此得名“分支指令”。这里所说的“机器码”既指计算机执行的代码，也指虚拟机运行的字节码。转换成我们 VM 的技术术语来说：跳跃是指令，告诉 VM 改变其指令指针至某个特定值。下面是它是如何工作的。

假设——纯属假设——我们有两种跳转操作码，分别命名为 `JUMP_IF_NOT_TRUE` 和 `JUMP_NO_MATTER_WHAT` 。我们可以用它们来填补上面指令图中的空白，如下所示：

![操作栈](/pic/条件语句6.png)

当 VM 从上到下顺序执行这些指令时，它会首先执行构成条件的指令，以 `OpGreaterThan` 指令结束。这会在栈顶留下一个布尔值。正如我们在上一章中定义和实现的一样。

下一个指令 `JUMP_IF_NOT_TRUE` 会告诉 VM 只有当栈顶的布尔值不是真时才跳转到 `OpConstant 4` 指令。如果是这种情况，VM 会跳过后果部分，直接跳到条件语句的“else”部分，即替代部分。而如果栈顶的布尔值为真， `JUMP_IF_NOT_TRUE` 就不会起作用，VM 会执行条件语句的后果部分。它会递增指令指针并开始取、解码和执行下一条指令—— `OpConstant 2` ，这是后果部分的开始。

这里变得有趣了。在执行完条件语句的后果部分——以 OpAdd 结束的三条指令后——VM 接下来会遇到恰如其名的 `JUMP_NO_MATTER_WHAT` 指令。这条指令没有附加任何条件，告诉 VM 直接跳转到条件语句替代部分之后的第一条指令，完全跳过替代部分。

这个小小的思维实验到此结束，并给出了一个明确的结果：如果我们有两个像这样的操作码，我们就能实现条件语句。但仍然有一个最后的问题：我们如何表示那些箭头？我们如何告诉 VM 跳转到哪里？

为什么不使用数字呢？跳跃是指令，告诉 VM 改变其指令指针的值，而上面图表中的箭头只不过是指令指针的潜在值。它们可以用数字表示，作为跳跃指令的操作数包含其中，其值就是 VM 应该跳转到的指令的索引。这个值称为偏移量。以这种方式使用时，跳转目标是指令的索引，这是一个绝对偏移量。相对偏移量也存在：它们相对于跳跃指令的位置，表示的不是确切的跳转位置，而是跳转的距离。

如果我们用偏移量代替箭头，并给每条指令分配一个独立于其字节大小的唯一索引（为了说明目的），图表看起来就像这样：

![操作栈](/pic/条件语句7.png)

`JUMP_IF_NOT_TRUE` 的操作数现在是 `0008` 。这是条件不为真时 VM 应该跳转到的 OpConstant 4 指令的索引。 `JUMP_NO_MATTER_WHAT` 的操作数是 `0011` ，这是整个条件语句之后的那条指令的索引。

这便是我们实现条件语句的方法！我们将定义两种跳转操作码：一种带有条件（“仅当不为真时跳转”），另一种则没有条件（“直接跳转”）。它们都将有一个操作数，即 VM 应该跳转到的指令的索引。

这就是我们的目标。问题是：我们如何达到这个目标？

|[⬅ 条件语句](./25条件语句.md)|[编译条件 ➡](./27编译条件.md)|
| --- | --- |
