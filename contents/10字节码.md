### 字节码

虚拟机执行的是字节码。就像计算机执行的机器码一样，字节码也是由指令组成的，这些指令告诉机器该做什么：推入这个，弹出那个，把这些加起来，调用这个函数。它被称为字节码是因为每个指令中包含的操作码（opcode）都是一个字节大小。

“操作码”是指令中的“运算符”部分，有时也称为“op”。我们之前看到的PUSH就是一个这样的操作码，只不过在我们的示例中它是一个多字节的字符串而不是单个字节。在一个合适的实现中，PUSH只是一个引用操作码的名字，而操作码本身是一个字节宽。像PUSH或POP这样的名字被称为助记符，它们帮助程序员记住和讨论操作码。

这些操作码的操作数（也称为参数或参数）也包含在字节码中。它们与操作码并排放置，操作数紧跟着操作码。然而，操作数并不一定是一个字节宽。例如，如果操作数是一个整数并且大于255，那么就需要多个字节来表示它。有些操作码有多个操作数，有些只有一个，还有一些则根本没有操作数。字节码是为寄存器机器还是堆栈机器设计的对此有很大影响。

你可以将字节码想象成一系列的操作码和操作数，它们在内存中彼此相邻排列：

![字节码示意](/pic/编译器和虚拟机5.png)

这有助于说明一般概念，但字节码是一种二进制格式，并不那么易读。这意味着你不能像读文本文件那样去阅读它。助记符，比如PUSH，在实际的字节码中是不会出现的。它们被替换为所指的操作码，而这些操作码只是数字——字节。具体是哪些数字取决于定义字节码的人。PUSH助记符可能代表数字0，而POP可能指的是数字23。

操作数也是编码过的，并且同样根据其值决定需要多少个字节来表示。如果一个操作数需要多个字节才能准确表示，那么它的编码顺序就非常重要了。有两种可能的顺序，称为小端序（little endian）和大端序（big endian）。小端序意味着原始数据中最不重要的字节首先出现，并存储在最低的内存地址中。大端序则相反：最重要的字节首先出现。

如果我们作为字节码设计者，声明PUSH对应于1，ADD对应于2，并且整数以大端序存储，那么我们可以将上面的例子编码并像这样在内存中布局：

![内存中布局](/pic/编译器和虚拟机6.png)

我们刚才所做的——将字节码的人类可读表示转换成二进制数据——是由称为汇编器的程序完成的。你可能在非虚拟机代码的上下文中听说过它们。在这里也是一样的道理。汇编语言是字节码的可读版本，包含助记符和可读的操作数，而汇编器则将其转换为二进制字节码。相反的过程，即将二进制表示转换为可读表示，则由反汇编器完成。

好了！关于字节码纯技术方面就讲到这里。进一步探讨会很快变得过于具体。由于字节码格式非常多样且专业化，使得我们难以在此做出更一般性的陈述。就像执行它的虚拟机一样，字节码是为一个非常特定的目标而创建的。

字节码是一种针对特定领域的机器语言。它是为定制构建的虚拟机量身定做的机器语言。这就是它的力量所在。字节码不需要是通用的，也不需要支持所有可以想象到的使用场景；它可以是专门化的，只需要支持源语言（即被编译成字节码的语言）所需的特性即可。

不仅如此。除了只允许一组有限的指令外，它还可以包含仅在特定领域虚拟机的上下文中有意义的领域特定指令。例如，Java虚拟机（JVM）的字节码包含了这些指令： `invokeinterface` 用于调用接口方法， `getstatic` 用于获取类的静态字段， `new` 用于创建指定类的新对象。Ruby 的字节码有 `putself` 指令用来将 self 加载到堆栈上， `send` 用来向对象发送消息， `putobject` 用来将任何对象加载到堆栈上。而 Lua 的字节码有专门处理表和元组访问与操作的指令。你不会在通用 x86-64 CPU 的指令集中找到这些内容。

使用自定义字节码格式进行专门化的能力是最初构建虚拟机的主要原因之一。这不仅使编译、维护和调试变得更加容易，而且生成的代码也更加紧凑，因为表达某些内容所需的指令更少。这反过来又使代码执行得更快。

现在，如果所有关于定制虚拟机、量身定制的机器代码、手工构建的编译器的讨论没有激起你的兴趣，这是你最后的机会转身离开。我们将要动手实践了。

### 我们要做的事情，或者说是：虚拟机与编译器的二元性

构建一个虚拟机和一个相匹配的编译器首先需要我们解决一个类似于“先有鸡还是先有蛋”的问题：我们先构建哪一个？是生成还不存在的机器字节码的编译器？还是没有人为其编写任何代码的虚拟机？

对于这本书，我选择的答案是：我们将同时构建两者。

完全构建完一个再构建另一个（无论哪个先）是令人沮丧的。很难理解正在发生的事情以及你所做事情的目的。如果你先构建编译器并定义字节码，那么在不了解虚拟机将如何执行这些字节码的情况下，很难理解为什么事物会是现在这个样子。如果先构建虚拟机，也有其自身的挑战，因为需要首先定义字节码。这在不仔细考虑字节码旨在表示的源语言结构的情况下很难做到，这意味着无论如何你最终都得详细规划编译器。

当然，如果你已经有构建其中任何一个的经验，你知道你的目标是什么，因此可以选择任一选项。然而，对于我们来说，目标是从头开始学习如何构建两者。

这就是为什么我们将从小处着手。我们将构建一个只支持少量指令的小型虚拟机，以及一个只知道如何输出这些指令的小型匹配编译器。这样做可以让我们立即看到我们为什么要构建这些东西，以及所有部分是如何拼合在一起的。从一开始就有一个可运行的系统，这给了我们快速反馈循环，并允许我们调整、实验和逐步构建我们的虚拟机器和编译器。这也让整个过程变得非常有趣。

现在你知道了计划是什么。你也已经对编译器和虚拟机有了足够的了解，这样我们就不会在过程中迷失方向。让我们开始吧。

|[⬅ 什么是虚拟机](./9为什么构建一个.md)|[字节码 ➡](./11hello字节码.md)|
| --- | --- |
