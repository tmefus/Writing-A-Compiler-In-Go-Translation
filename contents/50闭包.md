## 闭包

是时候完成我们对 Monkey 的新实现了，添加最后一个缺失的部分 – `closures` 。这无疑是其中最珍贵的功能之一，并且是在字节码编译器和虚拟机领域中定义类别的特性之一。支持它的并不多，很快你就会明白这是为什么。

首先，让我们简单回顾一下什么是 `closures` 以及它们是如何工作的。以下是一个经典的例子：

```
let newAdder = fn(a) {
let adder = fn(b) { a + b; };
    return adder;
};
let addTwo = newAdder(2);
addTwo(3); // => 5
```

新实现的 newAdder 函数返回一个名为 `adder` 的闭包。它是一个闭包，因为它不仅使用了自己的参数 `b` ，还访问了在 newAdder 中定义的参数 `a` 。在 `adder` 从 newAdder 返回后，它仍然可以访问这两个参数。这就是为什么 adder 是一个闭包，也是为什么当用 `3` 调用 `addTwo` 时它会返回 `5` ——它是 `adder` 函数的一个版本，仍然可以访问之前的 `a` 值，即 `2` 。

这就是通过六行代码解释的“什么是闭包？”。

我们在《Writing An Interpreter In Go》中的解释器也支持闭包，尽管那个实现与我们将在本章构建的内容有显著不同，但回顾一下有助于设定背景，因此这里是对我们在《Writing An Interpreter In Go》中走向闭包的一个大致路径。

首先，我们在 `object.Function` 中添加了一个 `Env` 字段来保存 `*object.Environment` ，这是用来存储全局和局部绑定的地方。

当我们评估一个 `*ast.FunctionLiteral` （将其转换为 `*object.Function` ）时，我们将当前环境的指针放入新函数的 `Env` 字段中。当调用该函数时，我们在 `Env` 字段中所存的那个环境中评估其主体。这一切的实际效果就是让函数始终能够访问它们被定义时所在环境的绑定，即使是在很久之后和任何地方。这种能力是使闭包成为闭包并区分它们与普通函数的原因。

我之所以想要再次回顾旧的实现，是因为它与我们思考闭包的方式非常接近：它们是“封闭”在其定义时的环境上的函数，围绕着这个环境，并携带它移动，就像 `Env` 字段中的 `*object.Environment` 指针一样。这是理解闭包最重要的一点。

现在我们需要再次实现闭包，不过这次我们没有树形遍历解释器。我们有一个编译器和虚拟机，这提出了一个根本性的问题。

### 问题

问题不在于我们不再评估函数字面量；问题并不在评估本身。在我们当前的实现中，我们仍然将 `*ast.FunctionLiterals` 转换为 `object.Objects` ；这意味着我们将它们转换为可以传递的东西，并且最重要的是，转换为可以被调用和执行的东西。在这个意义上，语义没有改变。

发生变化的是闭包创建的时间和地点。

在我们旧的解释器中，函数字面量到 `object.Function` 的转换以及封闭环境（设置该 `object.Function` 的 `Env` 字段）发生在完全相同的时间甚至是在同一个代码块中。

在我们新的 Monkey 实现中，这不仅发生在不同的时间，而且是在两个不同的包中进行：我们在编译器中编译函数字面量，在虚拟机中构建环境。结果是我们不能在编译函数时封闭一个环境，因为，嗯，此时还没有环境。

让我们试着通过心理上跟随上面的代码片段，看看它如何通过我们当前的实现来变得更具体一些。

首先发生的是我们编译它。两个函数 – `newAdder` 和 `adder` – 都被转换成一系列指令并添加到常量池中。之后，我们发出 OpConstant 指令以指示 VM 将函数加载到堆栈上。在这一点上，编译完成，但没有人知道 `a` 的值将会是什么。

然而，在 VM 中，一旦我们执行 `newAdder` ， `a` 的值就是已知的。但是，到那时， `adder` 已经被编译过，其指令将简单地被加载到堆栈上，包含在一个 `*object.CompiledFunction` 中，并从 `newAdder` 返回——没有任何机会去“封闭” `a` 。

你可以看到挑战所在了。在 VM 中，我们需要在 `adder` 从 `newAdder` 返回之前将其值 `a` 放入已经编译好的 adder 函数中，并且我们需要这样做，以便 `adder` 后续能够访问它。

是的，这意味着编译器必须在此之前发出指令，每当 `adder` 引用 `a` 时，就将其放到堆栈上。考虑到 `a` 既不是局部绑定也不是全局绑定，并且它的“位置”在我们执行 `newAdder` 和后续调用返回的 `adder` 函数之间发生了变化，先是在作用域内，然后……好吧，然后它必须在某个地方，让 `adder` 仍然能够访问它。

换句话说：我们需要给编译后的函数提供一种能力，即持有仅在运行时创建的绑定，并且它们的指令必须已经引用这些绑定。然后，在运行时，我们需要指示 VM 在正确的时间使这些绑定对函数可用。

这确实是一个艰巨的任务，不是吗？除此之外，我们不再有一个单一的环境。在我们的树形遍历解释器中的环境现在分散在全球存储和堆栈的不同区域中，所有这些都可能随着函数的返回而被清除。

如果你刚刚轻声说了句“呼”，这里还有另一个：我们仍然面临着嵌套局部绑定的问题。不过没关系，因为这个问题的解决方案与我们未来的闭包实现紧密相连。当然，你可以在不考虑闭包的情况下实现嵌套局部绑定，但我们将会通过一次实现获得两个特性。

让我们开始工作并制定一个计划。

### 计划

确实，实现闭包的方法并非只有一种。相反，存在多种方法，每一种都有其独特之处。并不是所有的方法都以文档形式公开详细描述，大多数仅在代码中体现，并且这些代码通常经过优化以节省最后一字节的内存并争取宝贵的毫秒性能提升，这——一般来说——并不利于其易读性。如果你将搜索范围缩小到字节码编译器和虚拟机，那么愿意深入研究代码就成为了硬性要求。

我们的实现将基于我发现最易接近且能够转移到 Monkey 的资源和代码库。这里的主要影响来源是 GNU Guile，一个带有出色调试工具的 Scheme 实现。其次是多个 Lua 的实现以及 Wren 的优美代码库，后者之前启发了《Writing An Interpreter In Go》。Matt Might 关于编译闭包的文章也非常有价值，如果你想更深入地探讨这个话题，我强烈推荐他的文章。

在我们深入细节并为我们的实现制定计划之前，我们需要扩展我们的词汇表并引入一个新的术语，这个术语可以在所有前述的实现和资源的核心位置找到。它就是：“free variable”。再看一下这段代码片段的这部分：

翻译后的文本保持了原文的格式和结构，同时保留了专有名词和代码词汇，并使用前后空格进行隔离。在这里，“free variable” 是指那些在函数内部定义但不是函数参数也不是局部变量的变量，它们的值来自于定义该函数的环境外部。对于闭包而言，处理“free variable”的方式至关重要，因为闭包需要在其被调用时仍然能够访问这些变量的值。

```
let newAdder = fn(a) {
let adder = fn(b) { a + b; };
    return adder;
};
```

从 `adder` 的角度来看， `a` 是一个 free variable。我必须承认这对我来说从来不是一个直观的名字，但 free variables 指的是那些既不在当前局部作用域中定义也不是当前函数参数的变量。因为它们不绑定到当前作用域，所以它们是“自由”的。另一个定义解释说，free variables 是那些在局部使用但在外部作用域中定义的变量。

使用编译器和虚拟机实现闭包围绕着 free variables 展开。编译器需要检测对这些变量的引用并发出指令以将它们加载到堆栈上，即使是在它们已经超出作用域的情况下。在对象系统中，编译后的函数必须能够携带 free variables。而且虚拟机不仅必须正确解析对 free variables 的引用，还必须存储它们于编译后的函数上。

我们将通过以下方式来实现这一点：我们将把每个函数都变成一个闭包。是的，并不是每个函数都是闭包，但我们仍将如此对待它们。这是一种保持编译器和虚拟机架构简单的方法，同时也帮助我们减少一些认知负担。（如果你追求性能，你会发现这个决定创造了大量的优化可能性。）

让我们将其转换为实际术语。首先，我们将在 `object` 包中定义一个新的对象，称为 Closure。它将包含一个指向 `*object.CompiledFunction` 的指针以及一个存放它所引用并携带的 free variables 的地方。

函数本身的编译不会改变。我们仍然会将 `*ast.FunctionLiteral` 编译成 `*object.CompiledFunction` 并将其添加到常量池中。

但是在编译函数体时，我们将检查每个我们解析的符号以确定它是否是对 free variable 的引用。如果是的话，我们不会发出 OpGetLocal 或 OpGetGlobal 指令，而是发出一个新的操作码，该操作码从对象 Closure 的“存储 free variables”部分加载值。我们必须扩展我们的 `SymbolTable` 以便它可以处理这一部分。

在函数体被编译并且我们在编译器中离开了它的作用域之后，我们将检查它是否引用了任何 free variables。我们升级后的 `SymbolTable` 应该告诉我们引用了多少个以及它们最初是在哪个作用域中定义的。最后一个属性特别重要，因为下一步是将这些 free variables 转移到编译后的函数——在运行时。为此，我们首先必须发出指令，以将引用的 free variables 加载到堆栈上，为了做到这一点，我们必须知道这些绑定是在哪个作用域中创建的。否则我们不知道要发出哪些指令。

之后我们将发出另一个新的操作码，指示 VM 从常量池中获取指定的函数，取下刚才压入堆栈的 free variables 并将它们转移到编译后的函数。这将使 `*object.CompiledFunction` 变成一个 `*object.Closure` 并将其压入堆栈。当它在堆栈上时，它可以像之前的 `*object.CompiledFunctions` 一样被调用，只是它现在可以访问其指令引用的 free variables。它已经被转化成了一个闭包。

总结一下：在编译函数时检测对 free variables 的引用，将引用的值放到堆栈上，将值和编译后的函数合并成一个闭包，并将其留在堆栈上，在那里它就可以被调用了。让我们开始吧。

|[⬅ 执行内置函数](./49执行内置函数.md)|[都是闭包 ➡](./51都是闭包.md)|
| --- | --- |
