## 条件语句

上一章的内容较为机械，因为我们一旦知道了如何向 Monkey 实现中添加一个运算符，就可以按照相同的步骤为其他运算符做同样的事情。然而，在这一章中，我们要提升一个层次。

我们需要回答一个非常具体的问题：如何让我们的 VM 根据条件执行不同的字节码指令？正如我们将要看到的，这个问题背后隐藏着许多小难题，解决这些问题是非常有趣的，特别是当我们深入到细节之中时。但在我们这样做之前，我们必须不写任何代码就回答这个问题。

因此，让我们给这个问题提供一些背景，并对其进行框架化。Monkey 的条件语句看起来是这样的：

```
if (5 > 3) {
    everythingsFine();
} else {
    lawsOfUniverseBroken();
}
```

如果条件 `5 > 3` 评估为真值，则执行第一个分支。这个分支包含了 everythingIsFine()。如果条件不是真值，则执行 else 分支，即包含 lawsOfUniverseBroken() 的分支。第一个分支被称为条件语句的“后果”，而 else 分支则被称为“替代”。

为了提供一个条件语句实现的蓝图，并刷新您的记忆，让我快速回顾一下《Writing An Interpreter In Go》中条件语句的实现。

当我们在求值器包的 Eval 函数中遇到 `*ast.IfExpression` 时，我们会评估它的 Condition 并使用 isTruthy 函数检查结果。如果值为真值，我们就会评估 `*ast.IfExpression` 的 Consequence。如果不为真值且 `*ast.IfExpression` 有一个 Alternative，我们就会评估这个 Alternative。但如果没有任何 Alternative，我们就返回一个 *object. Null。

总的来说，实现条件语句只用了大约 50 行代码。之所以能如此轻松地实现，是因为我们手中有 AST 节点。我们可以决定评估 `*ast.IfExpression` 的哪一侧，因为我们在这两个选项中都有选择权。

但现在情况不再是这样了。我们不再一边遍历 AST 一边执行它，而是将 AST 转换为字节码并将其展平。“展平”是因为字节码是一系列指令，没有子节点可以让我们选择是否遍历。这就把我们带回到了本章隐藏的主要问题和另一个需要解决的问题：如何在字节码中表示条件语句？

假设我们有以下 Monkey 代码：

```
if (5 > 2) {
    30 + 20
} else {
    50 - 25
}
```

我们已经知道如何在字节码中表示条件 `5 > 2` ，因为我们在上一章实现了这一点：

![操作栈](/pic/条件语句1.png)

我们也知道如何表示后果，即 `30 + 20` ：

![操作栈](/pic/条件语句2.png)

表示替代方案，也就是 `50 - 25` ，只是上述情况的一个变体：

![操作栈](/pic/条件语句3.png)

但是，我们如何告诉机器根据 `OpGreaterThan` 指令的结果来决定执行其中一个部分还是另一个部分呢？

![操作栈](/pic/条件语句4.png)

如果我们把这些指令作为一条平坦的指令序列传递给 VM，会发生什么？VM 会依次执行所有指令，愉快地递增指令指针，取指令、解码并执行，毫不关心，没有任何决策或分支。而这正是我们不想看到的！

我们希望的是 VM 要么执行 OpAdd 指令，要么执行 OpSub 指令。但由于我们确实是以平坦的指令序列形式传递字节码的，我们该如何实现这一点呢？如果我们重新排列指令图以表示一条平坦的指令序列，问题就变成了：我们应该如何填补这里的空白？

![操作栈](/pic/条件语句5.png)

我们需要在空白处填入某些内容，以便根据 `OpGreaterThan` 指令的结果，VM 要么忽略后果部分的指令，要么忽略替代部分的指令。它应该跳过这些指令。或者不如说，“跳过”可能比“忽略”更贴切？

|[⬅ 前缀表达式](./24前缀表达式.md)|[跳转 ➡](./26跳转.md)|
| --- | --- |
