## 函数

这是本书中最具挑战性的章节之一。在本章结束时，我们将实现函数和函数调用，包括局部绑定和函数调用参数。但要达到这个目标，我们必须进行大量的思考，并做出许多看似无害但却对我们的 Monkey 实现有重大影响的小改动。一路上我们会遇到不止一个挑战。因为，要知道，实现函数的问题在于：它不是一个简单的问题。

第一个问题是关于如何表示函数。一个天真的假设是函数是一系列指令。但在 Monkey 中函数也是头等公民，可以被传递并从其他函数返回。我们如何表示可以被传递的一系列指令呢？

一旦我们解决了这个问题，还有控制流的问题。我们如何让我们的 VM 执行函数的指令？再者，如果我们成功做到了这一点，我们又如何让它返回到之前执行的指令？并且，在此期间：我们如何让它将参数传递给函数？

这些问题是我们面临的主要问题——后面还跟着无数不能忽视的小问题。请放心，我们将回答所有这些问题。只是不会一次性全部解决。相反，我们将通过深思熟虑的小步骤，将许多不同的部分编织成一个连贯的整体，这也是使得本章特别有趣的原因。

### 浅尝辄止：一个简单的函数

我们的目标是在这一节中“仅仅”将这段看似简单的 Monkey 代码编译并执行：

```
let fivePlusTen = fn() { 5 + 10 };
fivePlusTen();
```

这个函数没有参数。它不使用局部绑定。它在被调用时没有传递参数，也不访问全局绑定。虽然我敢说目前可能存在并不是很多高度复杂的 Monkey 程序，但这个确实属于较为简单的一个。即便如此，它仍然带来了多个挑战。

### 表示函数

在我们考虑编译或执行这个函数之前，我们遇到了第一个挑战：如何表示函数？

我们知道一个函数包含 Monkey 代码。我们也知道我们会将 Monkey 代码编译成 Monkey 字节码。由此可以推断，我们的编译器应该将函数转换为至少一系列的 Monkey 字节码指令。问题是，我们把这些指令存储在哪里，以及我们如何将它们传递给虚拟机（VM）？

我们已经将主程序的指令传递给了 VM，但我们不能简单地把函数的指令与主程序的指令混合在一起。如果我们那样做，我们在 VM 中将不得不再次解开这些指令以便逐个执行它们。最好从一开始就保持它们的分离。

解答我们问题的关键在于 Monkey 函数是 Monkey 值的事实。它们可以绑定到名称上，可以从其他函数返回，作为参数传递给其他函数等等——就像任何其他的 Monkey 值一样。而且像其他值一样，它们也是由表达式产生的。

这些表达式就是函数字面量（function literals），即 Monkey 代码中函数的字面表示。在上面的例子中，函数字面量是这部分：

```
fn() { 5 + 10 }
```

关于函数字面量的一个有趣之处在于，它们产生的值不会改变。它是常量。这就是我们所需要的最后一个提示。

我们将像处理产生常量值的其他字面量一样对待函数字面量，并将它们作为——请注意——常量传递给虚拟机（VM）。我们将它们编译成指令序列，并将这些指令添加到编译器的常量池中。然后通过 OpConstant 指令负责将编译后的函数放到栈上——就像任何其他值一样。

现在，剩下的问题是如何准确地表示这些指令序列，以便它们可以被添加到常量池并加载到栈上。

在《Writing An Interpreter In Go》一书中，我们定义了 `object.Function` ，这是一个代表已求值的函数字面量的 Monkey 对象，该对象本身也可以被求值。现在我们需要这个概念的一个更新版本：一个包含字节码而不是抽象语法树（AST）节点的函数对象。

为此，我们打开我们的 `object` 包，并引入新的 `object.CompiledFunction` ：

```Go
// object/object.go

import (
    // [...]
    "monkey/code"
    // [...]
)

const (
    // [...]
    COMPILED_FUNCTION_OBJ = "COMPILED_FUNCTION_OBJ"
)

type CompiledFunction struct {
    Instructions code.Instructions
}

func (cf *CompiledFunction) Type() ObjectType { return COMPILED_FUNCTION_OBJ }
func (cf *CompiledFunction) Inspect() string {
    return fmt.Sprintf("CompiledFunction[%p]", cf)
}
```

确实， `object.CompiledFunction` 就是我们所需要的：它可以保存从函数字面量编译得到的 `code.Instructions` ，并且作为一个 `object.Object` ，我们可以将其作为常量添加到编译器的 Bytecode 中，并在 VM 中加载它。第一个问题已经解决。现在，让我们开始考虑编译过程。

### 执行函数的操作码

我们首先要问自己的问题是，是否需要新的操作码来实现我们编译和执行上述 Monkey 代码片段的目标。

让我们从不需要的东西开始：函数字面量的操作码。因为我们决定将它们编译为 `*object.CompiledFunction` 并将其视为常量，所以可以通过现有的 OpConstant 指令将它们加载到虚拟机的栈上。

因此，就操作码而言，我们可以划掉代码片段的第一行：

```
let fivePlusTen = fn() { 5 + 10 };
fivePlusTen();
```

一旦我们将函数字面量编译为 `*object.CompiledFunction` ，我们已经知道如何将其绑定到 fivePlusTen 名称。我们有全局绑定机制，并且它们可以与任何 `object.Object` 工作。

但我们确实需要一个针对第二行的操作码：fivePlusTen()。这是一个调用表达式，在我们的抽象语法树（AST）中由 *ast. CallExpression 表示，它必须被编译成一条指令，以告知虚拟机执行相关的函数。

由于我们没有符合这一需求的操作码，我们现在需要定义一个新的。它被称为 OpCall 并且它没有任何操作数：

```Go
// code/code.go

const (
    // [...]
    OpCall
)

var definitions = map[Opcode]*Definition{
    // [...]
    OpCall: {"OpCall", []int{}},
}
```

以下是 OpCall 的使用方式。首先，我们将想要调用的函数放到栈上。例如，通过一条 OpConstant 指令来实现。然后，我们发出一条 OpCall 指令。这会告知虚拟机执行栈顶的函数，之后程序继续运行。

这个简短的 OpCall 使用说明被称为调用约定（calling convention）。一旦我们增加了对函数调用参数的支持，它将会有所变化，但目前而言，它只是两个步骤：将你想要调用的函数放到栈上，然后发出 OpCall 指令。

定义了 OpCall 之后，我们现在理论上已经能够把一个函数加载到虚拟机的栈上并调用它。但我们仍然需要一种方法来指示虚拟机从被调用的函数返回。

更具体地说，我们需要区分两种情况下虚拟机必须从函数返回的情形。第一种情况是函数实际上返回某个值，无论是隐式还是显式的返回。第二种情况是当函数执行结束而没有返回任何东西时，例如函数有一个空的函数体。

让我们先讨论第一种情况，即值的显式和隐式返回。Monkey 同时支持这两种返回方式：

```
let explicitReturn = fn() { return 5 + 10; };
let implicitReturn = fn() { 5 + 10; };
```

一个显式的 `return` 语句会停止函数其余部分的执行，并返回由 `return` 关键字后面表达式产生的值。在上述例子中，这个表达式是中缀表达式 `5 + 10` 。

如果没有 `return` 语句，函数调用的结果将是函数内部最后生成的值。这被称为隐式返回。

在我们之前使用 Go 编写的解释器中，隐式返回值是默认情况。显式的 `return` 语句是我们需要额外构建的功能。

然而，这次隐式返回将是对显式返回的一个轻微变种。或者换句话说，这两种情况将会编译成相同的字节码：

```
fn() { 5 + 10 }
fn() { return 5 + 10 }
```

这意味着，一方面，隐式返回和显式返回在底层是一样的——这总是让程序员感到高兴。但另一方面，这也意味着我们必须实现这两种机制，以便能够编译并运行上述的 fivePlusTen 函数。即使我们只使用隐式返回，也不能走捷径。但现在在编译器上付出的额外努力会在之后的虚拟机执行阶段使事情变得容易得多。

由于它们都被编译成相同的字节码，隐式返回和显式返回也将由相同的操作码表示。这个操作码被称为 OpReturnValue，它告诉虚拟机带着返回值从函数返回：

```Go
// code/code.go

const (
    // [...]
    OpReturnValue
)

var definitions = map[Opcode]*Definition {
    // [...]
    OpReturnValue: {"OpReturnValue", []int{}},
}
```

操作码 OpReturnValue 确实不带有任何参数。要返回的值必须已经在栈顶等待。

对于显式返回的情况，何时以及如何发出这个操作码是很明确的。首先，编译 return 语句，使返回值最终位于栈顶，然后发出 OpReturnValue 操作码。这部分没有谜题，正如我们期望的那样直接。

实现隐式返回需要稍微多一点的努力，因为它还意味着返回由表达式语句产生的值——如果该表达式语句是函数体中最后执行的语句的话。但是之前我们确保了表达式语句不会在栈上留下值；我们明确地发出了 OpPop 指令来清除它。如果我们现在想要返回这个值，我们需要找到一种方法来结合我们对干净栈的需求与对隐式返回的期望。不过别担心，我们会解决这个问题。目前，可以先把这个议题放在脑后。

现在来讨论从函数返回时第二种且更为罕见的情况：函数不返回任何东西。既不是显式也不是隐式的返回。因为在 Monkey 中几乎一切都是产生值的表达式，所以能构思出这样一个函数本身就是一项成就，但这样的函数确实存在。这里有一个例子：

```
fn() { }
```

这是一个具有空函数体的函数。编译它会产生一个有效的 `*object.CompiledFunction` ，这个编译后的函数可以被调用，但不包含任何指令。当调用这样的函数时，它将执行完后立即返回，通常我们会设计虚拟机在这种情况下来返回一个默认值，比如 nil 或者 void，以表示没有实际返回值。

另一个例子，我们在讨论局部绑定（local bindings）时会再次遇到，是这样的一个函数：

```
fn() { let a = 1; }
```

确实，一个不返回任何值的函数是一个边缘情况，在我们最初编写的内容中甚至没有处理这种情况。但现在它摆在我们面前，伴随着一个未解的问题：这些函数应该产生什么？由于函数调用在 Monkey 中是表达式，而表达式会产生值，为了保持一致性，这些函数也应该产生一个值。

我们可以选择忽略这个问题，将其归入 `undefined_behaviour.txt` 文件中，并认为这是一个可以接受的未定义行为。但我们也可以决定让这些函数返回 `*object.Null` 。因为在 Monkey 中， `*object.Null` 表示不存在值，所以对于一个没有生成值的函数来说，返回 Null 是合理的。

既然已经做出了决定，这意味着我们需要告诉我们的虚拟机（VM），当一个函数在其结束处没有 OpReturnValue 指令时，应该返回 `vm.Null` 。我们将通过引入另一个操作码来实现这一点。

之前定义的 OpReturnValue 操作码指示 VM 返回栈顶的值作为返回值。新的操作码，我们称之为 OpReturn，也将告诉 VM 从当前函数返回，但这次不同的是，栈上没有任何东西，没有返回值，什么都没有。只是简单地回到调用这个函数之前的状态继续执行。

下面是它的定义：

```Go
// code/code.go

const (
    // [...]
    OpReturn
)

var definitions = map[Opcode]*Definition {
    // [...]
    OpReturn: {"OpReturn", []int{}},
}
```

确实，我们现在有了三个新的操作码——这足以开始在编译器中实现它们了。

|[⬅ 添加索引操作符](./36添加索引操作符.md)|[编译函数字面量 ➡](./38编译函数字面量.md)|
| --- | --- |
