## 编译器

如果让你说出一个编译器的名字，你可能毫不迟疑地给出像GCC、Clang或Go编译器这样的答案。不管怎样，这很可能是一个用于编程语言的编译器，而且很有可能是用来生成可执行文件的。我也会这么做，因为我们通常就是这样理解“编译器”这个词的。

但事实上，编译器有着各种不同的形态和规模，它们不仅可以编译编程语言，还可以处理诸如正则表达式、数据库查询乃至HTML模板等其他类型的内容。我敢说你每天都在无意识中使用了一种或几种编译器。这是因为“编译器”这个词的定义其实相当宽泛，远比人们想象的要灵活得多。这是<b style="color: red; ">维基百科</b>对于编译器的定义：

> 编译器是一种计算机软件，它将用一种编程语言（源语言）编写的计算机代码转换成另一种编程语言（目标语言）。编译器是一种支持数字设备，主要是计算机的翻译工具。术语“编译器”主要用于指那些将高级编程语言的源代码翻译成低级语言（例如汇编语言、目标代码或机器码）以创建可执行程序的程序。

编译器是翻译器。这个说法可能听起来有些模糊。一个将高级语言翻译成可执行文件的编译器只是众多编译器类型中的一种特别类型。这似乎与直觉相悖，因为人们通常认为生成可执行文件就是编译器的工作：GCC、Clang 和 Go 编译器都是这样做的。那么为什么这不被认为是编译器定义的核心呢？

答案在于对“可执行文件”的理解。如果将可执行文件视为计算机可以直接理解的语言中的源代码，那么“编译成本地代码”就等同于编译成机器码。因此，生成可执行文件确实只是“翻译源代码”的一种变体。

让我们通过退一步来理解这一点。编程意味着向计算机发出指令。作为程序员，我们用计算机可以理解的编程语言编写这些指令。实现一种编程语言意味着让计算机能够理解它。有两种方法可以做到这一点：要么实时解释这种语言给计算机听，要么将其翻译成另一种计算机已经理解的语言。

这就像是我们人类帮助不懂某种语言的朋友理解一样。我们可以选择边听边在心里翻译然后口头转述给她，或者我们可以把翻译写下来让她自己阅读和理解。我们既可以充当口译员也可以充当编译器。

虽然它们的方法不同，但解释器和编译器在其构造上有很多共同之处。它们都有一个前端，读取用源语言编写的源代码并将其转换为数据结构。无论是编译器还是解释器，前端通常由词法分析器（lexer）和语法分析器（parser）组成，这两个组件共同生成一个语法树。在这里，它们的前部分有很多相似之处。之后，当它们遍历抽象语法树（AST）时，它们的路径就开始分叉了。

既然我们已经构建了一个解释器，我们知道它在遍历 AST 时做了什么：它会评估 AST。也就是说，它执行编码在树中的指令。如果树中的一个节点代表源语言语句 puts("Hello World!")，那么解释器在评估该节点时会打印出“Hello World!”。

相比之下，编译器不会立即打印任何内容。相反，它会在另一种语言（称为目标语言）中生成源代码。这段源代码将包含目标语言中相当于源语言 puts("Hello World!") 的等效表达。生成的代码随后可以被计算机执行，并且屏幕上会出现“Hello World!”。

这时事情变得非常有趣。编译器生成的目标语言是什么？计算机能理解哪种语言？编译器如何以这种语言生成代码？是以文本形式还是二进制格式？是在文件中还是在内存中？更重要的是：它在这种目标语言中究竟生成了什么？如果目标语言没有 puts 的等效物，编译器应该生成什么？

通常来说，对于这些问题，我们必须给出相同的回答：软件开发中最常见的答案，也是编程中唯一的硬性真理——“视情况而定。”

很遗憾，这样的回答可能让人失望，但这些问题的答案取决于许多变量和要求：源语言、执行目标语言的机器架构、输出的使用方式（直接执行？再次编译？解释？）、输出需要多快运行、编译器本身需要多快运行、生成的源代码可以有多大、编译器允许使用的内存有多少、生成的程序可以使用的内存量以及更多因素。

编译器之间的差异非常大，以至于我们无法对它们的架构做出很多通用性的描述。尽管如此，我们可以暂时忽略这些细节，勾勒出一个典型的编译器架构:

![执行流程](/pic/编译器和虚拟机2.png)

这描述了源代码被翻译成机器码的生命周期。以下是发生的过程：

首先，源代码由词法分析器（lexer）和语法分析器（parser）进行分词和解析。这部分我们从解释器中已经熟悉，它被称为前端。源代码从文本转换为抽象语法树（AST, Abstract Syntax Tree）。

之后，一个称为“优化器”（有时也称为“编译器”）的组件可能会将AST转换为另一种内部表示（IR, Intermediate Representation）。这种额外的IR可能只是另一个语法树，或者可能是二进制格式，甚至是文本格式。转换为IR的原因有很多，但主要原因是IR可能比AST更适合进行优化和目标语言的翻译。

新的IR随后会经历一个优化阶段：删除无用代码、预先计算简单的算术运算、将不需要在循环体内的代码移出循环等。存在大量的可能优化措施。

最后，代码生成器（也称为后端）生成目标语言的代码。这就是编译实际发生的地方。可以说，此时代码进入了文件系统。之后，我们可以执行结果并看到计算机按照我们在原始源代码中的指示执行操作。

这就是最简单的编译器的工作方式。即便如此，这里也可能有上千种变体。例如，优化器可以对IR进行多次“遍历”，这意味着它会多次遍历IR，并且每次执行不同的优化：一次遍历中删除无用代码，在另一次遍历中内联函数调用等。或者，编译器可能根本不针对IR做优化，而只针对目标语言的源代码。或者只对AST，或两者都进行优化。或者根本不做任何优化。或者除了AST之外没有其他IR。或者它不输出机器码，而是汇编语言或其他高级语言。或者它有多个后端，可以为多种架构生成机器码。这一切都取决于特定的使用场景。

而且，编译器并不一定是一个你运行在命令行上的工具，读取源代码并输出文件中的代码，像gcc或go那样。它也可以是一个接受AST并返回字符串的单一函数。那也是一种编译器。编译器可以用几百行代码编写，也可以包含数百万行代码。

但在所有这些代码之下，是翻译的基本思想。编译器接收一种语言的源代码并生成另一种语言的源代码。其余部分——再次强调——“取决于”，很大程度上取决于目标语言。目标语言的能力及其可执行的机器决定了编译器的设计。

现在，如果我们不必选择目标语言，而是可以发明自己的语言呢？而且，如果我们不止于此，还梦想出能够执行这种语言的机器呢？

|[⬅ 编译器和虚拟机](./5编译器和虚拟机.md)|[虚拟机和真实机 ➡](./7虚拟机和真实机.md)|
| --- | --- |