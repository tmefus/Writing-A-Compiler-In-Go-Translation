## 第一个指令

正如我在前一章中提到的，虚拟机的架构是字节码外观的最大影响因素。这意味着在我们开始指定字节码之前，需要先决定我们要构建哪种类型的机器。

那么，不绕弯子了：我们将要构建一个栈式机器！为什么呢？因为对于初学者来说，栈式机器比寄存器式机器更容易理解和构建。概念更少，活动部件也更少。至于性能考量——寄存器式机器是否更快？——对我们来说并不是很重要。我们的优先事项是学习和理解。

稍后我们会看到这个决定带来的更多影响，但最直接且最实际的影响是我们现在必须进行栈运算。也就是说，为了达到编译并执行Monkey表达式1 + 2的目标，我们必须将其转换为使用栈的字节码指令。在栈式机器中工作时，我们不能只是简单地告诉它去加两个数，而不用到栈。

幸运的是，我们之前已经见过类似的例子，并且已经知道如何使用栈来进行算术运算。我们首先将操作数1和2放到栈上，然后告诉虚拟机：“把这些相加！”这条“把这些相加！”的指令应该会让虚拟机从栈顶取出两个元素，把它们相加，然后将结果压回栈上。这里是在指令执行前后栈的样子：

![栈示意](/pic/字节码3.png)

在实现这个功能时，我们需要告知虚拟机（VM）执行以下操作：
* 将1压入栈
* 将2压入栈
* 将栈顶的两个元素相加

为了完成这些操作，我们需要创建三条指令。然而，作为程序员我们知道只需要定义两种不同的指令类型，因为将2压入栈的操作与将1压入栈的操作是相同的，只是“参数”不同。因此总共需要两种指令类型：一种用于将数据压入栈，另一种用于对栈中已有的数据进行相加。

我们将以相同的方式实现这两种指令。首先我们定义它们的操作码（opcode）以及它们如何被编码为字节码。然后我们扩展编译器，使它能够生成这些指令。一旦编译器知道如何生成这些指令，我们就可以创建能够解码并执行这些指令的虚拟机。我们从告诉虚拟机将数据压入栈的指令开始。

|[⬅ hello字节码](./11hello字节码.md)|[从字节开始 ➡](./13从字节开始.md)|
| --- | --- |
